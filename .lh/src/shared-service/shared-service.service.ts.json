{
    "sourceFile": "src/shared-service/shared-service.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 53,
            "patches": [
                {
                    "date": 1749977315499,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1749977704898,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,17 +3,20 @@\n import { Business } from \"src/entities/business.entity/business.entity\";\r\n import { User } from \"src/entities/user.entity/user.entity\";\r\n import { DataResponse, NotFoundResponse } from \"src/models/response.dto\";\r\n import { UserResponse } from \"src/models/userResponse.dto\";\r\n+import { ProductCategory } from \"src/product-categories/entities/product-category.entity\";\r\n import { Repository } from \"typeorm\";\r\n \r\n @Injectable()\r\n export class SharedService {\r\n \tconstructor(\r\n \t\t@InjectRepository(User)\r\n \t\tprivate userRepo: Repository<User>,\r\n \t\t@InjectRepository(Business)\r\n-\t\tprivate businessRepo: Repository<Business>\r\n+\t\tprivate businessRepo: Repository<Business>,\r\n+\t\t@InjectRepository(ProductCategory)\r\n+\t\tprivate productRepo: Repository<ProductCategory>\r\n \t) {}\r\n \r\n \tasync findOneByEmail(\r\n \t\temail: string\r\n@@ -48,5 +51,20 @@\n \t\t}\r\n \r\n \t\treturn new DataResponse<Business>(business, \"Business Found\");\r\n \t}\r\n+\r\n+\tasync findProductCategoryById(\r\n+\t\tid: string\r\n+\t): Promise<DataResponse<ProductCategory> | NotFoundResponse> {\r\n+\t\tconst productCategory = await this.productRepo.findOneBy({ id });\r\n+\r\n+\t\tif (!productCategory) {\r\n+\t\t\treturn new NotFoundResponse(\"Product Category not found\");\r\n+\t\t}\r\n+\r\n+\t\treturn new DataResponse<ProductCategory>(\r\n+\t\t\tproductCategory,\r\n+\t\t\t\"Product Category Found\"\r\n+\t\t);\r\n+\t}\r\n }\r\n"
                },
                {
                    "date": 1749991976390,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,22 +1,33 @@\n-import { Injectable } from \"@nestjs/common\";\r\n+import { Injectable, Logger } from \"@nestjs/common\";\r\n import { InjectRepository } from \"@nestjs/typeorm\";\r\n import { Business } from \"src/entities/business.entity/business.entity\";\r\n import { User } from \"src/entities/user.entity/user.entity\";\r\n-import { DataResponse, NotFoundResponse } from \"src/models/response.dto\";\r\n+import {\r\n+\tDataResponse,\r\n+\tInvalidCredentialsResponse,\r\n+\tNotFoundResponse,\r\n+\tSuccessResponse,\r\n+} from \"src/models/response.dto\";\r\n import { UserResponse } from \"src/models/userResponse.dto\";\r\n import { ProductCategory } from \"src/product-categories/entities/product-category.entity\";\r\n+import { Product } from \"src/products/entities/product.entity\";\r\n+import { PurchaseDto } from \"src/purchase/dto/purchase.dto\";\r\n import { Repository } from \"typeorm\";\r\n \r\n @Injectable()\r\n export class SharedService {\r\n+\tprivate readonly logger = new Logger(SharedService.name);\r\n+\r\n \tconstructor(\r\n \t\t@InjectRepository(User)\r\n \t\tprivate userRepo: Repository<User>,\r\n \t\t@InjectRepository(Business)\r\n \t\tprivate businessRepo: Repository<Business>,\r\n \t\t@InjectRepository(ProductCategory)\r\n-\t\tprivate productRepo: Repository<ProductCategory>\r\n+\t\tprivate productCategoryRepo: Repository<ProductCategory>,\r\n+\t\t@InjectRepository(Product)\r\n+\t\tprivate productRepo: Repository<Product>\r\n \t) {}\r\n \r\n \tasync findOneByEmail(\r\n \t\temail: string\r\n@@ -55,9 +66,9 @@\n \r\n \tasync findProductCategoryById(\r\n \t\tid: string\r\n \t): Promise<DataResponse<ProductCategory> | NotFoundResponse> {\r\n-\t\tconst productCategory = await this.productRepo.findOneBy({ id });\r\n+\t\tconst productCategory = await this.productCategoryRepo.findOneBy({ id });\r\n \r\n \t\tif (!productCategory) {\r\n \t\t\treturn new NotFoundResponse(\"Product Category not found\");\r\n \t\t}\r\n@@ -66,5 +77,101 @@\n \t\t\tproductCategory,\r\n \t\t\t\"Product Category Found\"\r\n \t\t);\r\n \t}\r\n+\r\n+\tasync purchaseProduct(\r\n+\t\tuserId: string,\r\n+\t\tpurchaseDto: PurchaseDto[]\r\n+\t): Promise<\r\n+\t\t| DataResponse<PurchaseDto>\r\n+\t\t| NotFoundResponse\r\n+\t\t| SuccessResponse\r\n+\t\t| InvalidCredentialsResponse\r\n+\t> {\r\n+\t\tthis.logger.log(\"Processing purchase\", purchaseDto);\r\n+\t\tif (!purchaseDto || purchaseDto.length === 0) {\r\n+\t\t\tthis.logger.error(\"Purchase data is empty or undefined\");\r\n+\t\t\treturn new InvalidCredentialsResponse(\r\n+\t\t\t\t\"Invalid purchase data\",\r\n+\t\t\t\t\"Please provide valid purchase data\",\r\n+\t\t\t\t400\r\n+\t\t\t);\r\n+\t\t}\r\n+\r\n+\t\tconst totalPrice = 0;\r\n+\t\tthis.logger.log(\"Total price initialized\", totalPrice);\r\n+\r\n+\t\tfor (const purchase of purchaseDto) {\r\n+\t\t\t//Check if Product Exist\r\n+\t\t\tconst productResponse = await this.productRepo.findOneBy({\r\n+\t\t\t\tid: purchase.productId,\r\n+\t\t\t});\r\n+\r\n+\t\t\tconst productCategory = await this.findProductCategoryById(\r\n+\t\t\t\tproductResponse.category.id\r\n+\t\t\t);\r\n+\t\t\tthis.logger.log(\"Purchase response\", productCategory);\r\n+\r\n+\t\t\t//Check if Product Category Exists\r\n+\t\t\tconst foundProductCategory =\r\n+\t\t\t\tproductCategory instanceof DataResponse ? productCategory.data : null;\r\n+\t\t\tif (\r\n+\t\t\t\t!foundProductCategory ||\r\n+\t\t\t\tfoundProductCategory instanceof NotFoundResponse\r\n+\t\t\t) {\r\n+\t\t\t\tthis.logger.error(\r\n+\t\t\t\t\t\"Product category not found for purchase\",\r\n+\t\t\t\t\tpurchase.productId\r\n+\t\t\t\t);\r\n+\t\t\t\treturn new NotFoundResponse(\r\n+\t\t\t\t\t\"Product category not found\",\r\n+\t\t\t\t\t\"Please provide a valid product ID\"\r\n+\t\t\t\t);\r\n+\t\t\t}\r\n+\r\n+\t\t\tthis.logger.log(\r\n+\t\t\t\t\"Product category found for purchase\",\r\n+\t\t\t\tfoundProductCategory.name\r\n+\t\t\t);\r\n+\r\n+\t\t\t//Check if Business Exists\r\n+\t\t\tconst businessResponse = await this.findBusinessById(purchase.businessId);\r\n+\t\t\tthis.logger.log(\"Business response\", businessResponse);\r\n+\t\t\tconst foundBusiness =\r\n+\t\t\t\tbusinessResponse instanceof DataResponse ? businessResponse.data : null;\r\n+\r\n+\t\t\tif (!foundBusiness || foundBusiness instanceof NotFoundResponse) {\r\n+\t\t\t\tthis.logger.error(\r\n+\t\t\t\t\t\"Business not found for purchase\",\r\n+\t\t\t\t\tpurchase.businessId\r\n+\t\t\t\t);\r\n+\t\t\t\treturn new InvalidCredentialsResponse(\r\n+\t\t\t\t\t\"Business not found\",\r\n+\t\t\t\t\t\"Please provide a valid business ID\",\r\n+\t\t\t\t\t404\r\n+\t\t\t\t);\r\n+\t\t\t}\r\n+\t\t\tthis.logger.log(\r\n+\t\t\t\t\"Business found for purchase\",\r\n+\t\t\t\tfoundBusiness.businessName\r\n+\t\t\t);\r\n+\r\n+\t\t\t//Check if User Exists\r\n+\t\t\tconst userResponse = await this.userRepo.findOneBy({ id: userId });\r\n+\t\t\tthis.logger.log(\"User response\", userResponse);\r\n+\r\n+\t\t\tif (!userResponse) {\r\n+\t\t\t\tthis.logger.error(\"User not found for purchase\", userId);\r\n+\t\t\t\treturn new NotFoundResponse(\r\n+\t\t\t\t\t\"User not found\",\r\n+\t\t\t\t\t\"Please provide a valid user ID\"\r\n+\t\t\t\t);\r\n+\t\t\t}\r\n+\t\t\tthis.logger.log(\"User found for purchase\", userResponse.username);\r\n+\r\n+\t\t\tthis.logger.log(\r\n+\t\t\t\t`Processing purchase for user ${userResponse.username} of product ${foundProductCategory.name} from business ${foundBusiness.businessName}`\r\n+\t\t\t);\r\n+\t\t}\r\n+\t}\r\n }\r\n"
                },
                {
                    "date": 1749992336560,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,23 +97,31 @@\n \t\t\t\t400\r\n \t\t\t);\r\n \t\t}\r\n \r\n-\t\tconst totalPrice = 0;\r\n+\t\tlet totalPrice = 0;\r\n \t\tthis.logger.log(\"Total price initialized\", totalPrice);\r\n \r\n \t\tfor (const purchase of purchaseDto) {\r\n \t\t\t//Check if Product Exist\r\n \t\t\tconst productResponse = await this.productRepo.findOneBy({\r\n \t\t\t\tid: purchase.productId,\r\n \t\t\t});\r\n \r\n+\t\t\tthis.logger.log(\"Product response\", productResponse);\r\n+\t\t\tif (!productResponse || productResponse instanceof NotFoundResponse) {\r\n+\t\t\t\tthis.logger.error(\"Product not found for purchase\", purchase.productId);\r\n+\t\t\t\treturn new NotFoundResponse(\r\n+\t\t\t\t\t\"Product not found with ID: \" + purchase.productId,\r\n+\t\t\t\t\t\"Please provide a valid product ID\"\r\n+\t\t\t\t);\r\n+\t\t\t}\r\n+\t\t\t//Check if Product Category Exists\r\n \t\t\tconst productCategory = await this.findProductCategoryById(\r\n \t\t\t\tproductResponse.category.id\r\n \t\t\t);\r\n \t\t\tthis.logger.log(\"Purchase response\", productCategory);\r\n \r\n-\t\t\t//Check if Product Category Exists\r\n \t\t\tconst foundProductCategory =\r\n \t\t\t\tproductCategory instanceof DataResponse ? productCategory.data : null;\r\n \t\t\tif (\r\n \t\t\t\t!foundProductCategory ||\r\n@@ -169,9 +177,16 @@\n \t\t\t}\r\n \t\t\tthis.logger.log(\"User found for purchase\", userResponse.username);\r\n \r\n \t\t\tthis.logger.log(\r\n-\t\t\t\t`Processing purchase for user ${userResponse.username} of product ${foundProductCategory.name} from business ${foundBusiness.businessName}`\r\n+\t\t\t\t`Processing purchase for user ${userResponse.username} of product ${productResponse.name} from business ${foundBusiness.businessName}`\r\n \t\t\t);\r\n+\t\t\t// Calculate total price (assuming productResponse has a price property)\r\n+\t\t\tconst productPrice = productResponse.price || 0; // Assuming price is a property of Product\r\n+\t\t\ttotalPrice = productPrice * purchase.quantity;\r\n+\r\n+\t\t\tthis.logger.log(\r\n+\t\t\t\t`Total price for product ${productResponse.name} is ${totalPrice}`\r\n+\t\t\t);\r\n \t\t}\r\n \t}\r\n }\r\n"
                },
                {
                    "date": 1749992394305,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -187,6 +187,7 @@\n \t\t\tthis.logger.log(\r\n \t\t\t\t`Total price for product ${productResponse.name} is ${totalPrice}`\r\n \t\t\t);\r\n \t\t}\r\n+\t\tthis.logger.log(\"Total price calculated for all purchases\", totalPrice);\r\n \t}\r\n }\r\n"
                },
                {
                    "date": 1749993213074,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -102,8 +102,9 @@\n \t\tthis.logger.log(\"Total price initialized\", totalPrice);\r\n \r\n \t\tfor (const purchase of purchaseDto) {\r\n \t\t\t//Check if Product Exist\r\n+\t\t\tthis.logger.log(\"Checking product for purchase\", purchase;\r\n \t\t\tconst productResponse = await this.productRepo.findOneBy({\r\n \t\t\t\tid: purchase.productId,\r\n \t\t\t});\r\n \r\n"
                },
                {
                    "date": 1749993220537,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -102,9 +102,9 @@\n \t\tthis.logger.log(\"Total price initialized\", totalPrice);\r\n \r\n \t\tfor (const purchase of purchaseDto) {\r\n \t\t\t//Check if Product Exist\r\n-\t\t\tthis.logger.log(\"Checking product for purchase\", purchase;\r\n+\t\t\tthis.logger.log(\"Checking product for purchase\", purchase);\r\n \t\t\tconst productResponse = await this.productRepo.findOneBy({\r\n \t\t\t\tid: purchase.productId,\r\n \t\t\t});\r\n \r\n"
                },
                {
                    "date": 1749993282377,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -99,8 +99,9 @@\n \t\t}\r\n \r\n \t\tlet totalPrice = 0;\r\n \t\tthis.logger.log(\"Total price initialized\", totalPrice);\r\n+\t\tthis.logger.log(\"Purchase DTO\", purchaseDto);\r\n \r\n \t\tfor (const purchase of purchaseDto) {\r\n \t\t\t//Check if Product Exist\r\n \t\t\tthis.logger.log(\"Checking product for purchase\", purchase);\r\n"
                },
                {
                    "date": 1749993389743,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -99,9 +99,9 @@\n \t\t}\r\n \r\n \t\tlet totalPrice = 0;\r\n \t\tthis.logger.log(\"Total price initialized\", totalPrice);\r\n-\t\tthis.logger.log(\"Purchase DTO\", purchaseDto);\r\n+\t\tthis.logger.log(\"Purchase DTO\", JSON.stringify(purchaseDto));\r\n \r\n \t\tfor (const purchase of purchaseDto) {\r\n \t\t\t//Check if Product Exist\r\n \t\t\tthis.logger.log(\"Checking product for purchase\", purchase);\r\n"
                },
                {
                    "date": 1749993434322,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,9 +103,9 @@\n \t\tthis.logger.log(\"Purchase DTO\", JSON.stringify(purchaseDto));\r\n \r\n \t\tfor (const purchase of purchaseDto) {\r\n \t\t\t//Check if Product Exist\r\n-\t\t\tthis.logger.log(\"Checking product for purchase\", purchase);\r\n+\t\t\tthis.logger.log(\"Checking product for purchase\", purchase.productId);\r\n \t\t\tconst productResponse = await this.productRepo.findOneBy({\r\n \t\t\t\tid: purchase.productId,\r\n \t\t\t});\r\n \r\n"
                },
                {
                    "date": 1750234887890,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,28 +144,28 @@\n \t\t\t\tfoundProductCategory.name\r\n \t\t\t);\r\n \r\n \t\t\t//Check if Business Exists\r\n-\t\t\tconst businessResponse = await this.findBusinessById(purchase.businessId);\r\n-\t\t\tthis.logger.log(\"Business response\", businessResponse);\r\n-\t\t\tconst foundBusiness =\r\n-\t\t\t\tbusinessResponse instanceof DataResponse ? businessResponse.data : null;\r\n+\t\t\t// const businessResponse = await this.findBusinessById(purchase.businessId);\r\n+\t\t\t// this.logger.log(\"Business response\", businessResponse);\r\n+\t\t\t// const foundBusiness =\r\n+\t\t\t// \tbusinessResponse instanceof DataResponse ? businessResponse.data : null;\r\n \r\n-\t\t\tif (!foundBusiness || foundBusiness instanceof NotFoundResponse) {\r\n-\t\t\t\tthis.logger.error(\r\n-\t\t\t\t\t\"Business not found for purchase\",\r\n-\t\t\t\t\tpurchase.businessId\r\n-\t\t\t\t);\r\n-\t\t\t\treturn new InvalidCredentialsResponse(\r\n-\t\t\t\t\t\"Business not found\",\r\n-\t\t\t\t\t\"Please provide a valid business ID\",\r\n-\t\t\t\t\t404\r\n-\t\t\t\t);\r\n-\t\t\t}\r\n-\t\t\tthis.logger.log(\r\n-\t\t\t\t\"Business found for purchase\",\r\n-\t\t\t\tfoundBusiness.businessName\r\n-\t\t\t);\r\n+\t\t\t// if (!foundBusiness || foundBusiness instanceof NotFoundResponse) {\r\n+\t\t\t// \tthis.logger.error(\r\n+\t\t\t// \t\t\"Business not found for purchase\",\r\n+\t\t\t// \t\tpurchase.businessId\r\n+\t\t\t// \t);\r\n+\t\t\t// \treturn new InvalidCredentialsResponse(\r\n+\t\t\t// \t\t\"Business not found\",\r\n+\t\t\t// \t\t\"Please provide a valid business ID\",\r\n+\t\t\t// \t\t404\r\n+\t\t\t// \t);\r\n+\t\t\t// }\r\n+\t\t\t// this.logger.log(\r\n+\t\t\t// \t\"Business found for purchase\",\r\n+\t\t\t// \tfoundBusiness.businessName\r\n+\t\t\t// );\r\n \r\n \t\t\t//Check if User Exists\r\n \t\t\tconst userResponse = await this.userRepo.findOneBy({ id: userId });\r\n \t\t\tthis.logger.log(\"User response\", userResponse);\r\n@@ -179,9 +179,9 @@\n \t\t\t}\r\n \t\t\tthis.logger.log(\"User found for purchase\", userResponse.username);\r\n \r\n \t\t\tthis.logger.log(\r\n-\t\t\t\t`Processing purchase for user ${userResponse.username} of product ${productResponse.name} from business ${foundBusiness.businessName}`\r\n+\t\t\t\t`Processing purchase for user ${userResponse.username} of product ${productResponse.name} from business`\r\n \t\t\t);\r\n \t\t\t// Calculate total price (assuming productResponse has a price property)\r\n \t\t\tconst productPrice = productResponse.price || 0; // Assuming price is a property of Product\r\n \t\t\ttotalPrice = productPrice * purchase.quantity;\r\n"
                },
                {
                    "date": 1750235991536,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,10 +104,10 @@\n \r\n \t\tfor (const purchase of purchaseDto) {\r\n \t\t\t//Check if Product Exist\r\n \t\t\tthis.logger.log(\"Checking product for purchase\", purchase.productId);\r\n-\t\t\tconst productResponse = await this.productRepo.findOneBy({\r\n-\t\t\t\tid: purchase.productId,\r\n+\t\t\tconst productResponse = await this.productRepo.findOne({\r\n+\t\t\t\twhere: { id: purchase.productId },\r\n \t\t\t});\r\n \r\n \t\t\tthis.logger.log(\"Product response\", productResponse);\r\n \t\t\tif (!productResponse || productResponse instanceof NotFoundResponse) {\r\n"
                },
                {
                    "date": 1750236842065,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,9 +87,8 @@\n \t\t| NotFoundResponse\r\n \t\t| SuccessResponse\r\n \t\t| InvalidCredentialsResponse\r\n \t> {\r\n-\t\tthis.logger.log(\"Processing purchase\", purchaseDto);\r\n \t\tif (!purchaseDto || purchaseDto.length === 0) {\r\n \t\t\tthis.logger.error(\"Purchase data is empty or undefined\");\r\n \t\t\treturn new InvalidCredentialsResponse(\r\n \t\t\t\t\"Invalid purchase data\",\r\n@@ -99,22 +98,28 @@\n \t\t}\r\n \r\n \t\tlet totalPrice = 0;\r\n \t\tthis.logger.log(\"Total price initialized\", totalPrice);\r\n-\t\tthis.logger.log(\"Purchase DTO\", JSON.stringify(purchaseDto));\r\n+\t\tthis.logger.log(\"Purchase DTO\", JSON.stringify(purchaseDto, null, 2));\r\n \r\n-\t\tfor (const purchase of purchaseDto) {\r\n+\t\tfor (let i = 0; i < purchaseDto.length; i++) {\r\n \t\t\t//Check if Product Exist\r\n-\t\t\tthis.logger.log(\"Checking product for purchase\", purchase.productId);\r\n+\t\t\tthis.logger.log(\r\n+\t\t\t\t\"Checking product for purchase\",\r\n+\t\t\t\tpurchaseDto[i].productId\r\n+\t\t\t);\r\n \t\t\tconst productResponse = await this.productRepo.findOne({\r\n-\t\t\t\twhere: { id: purchase.productId },\r\n+\t\t\t\twhere: { id: purchaseDto[i].productId },\r\n \t\t\t});\r\n \r\n \t\t\tthis.logger.log(\"Product response\", productResponse);\r\n \t\t\tif (!productResponse || productResponse instanceof NotFoundResponse) {\r\n-\t\t\t\tthis.logger.error(\"Product not found for purchase\", purchase.productId);\r\n+\t\t\t\tthis.logger.error(\r\n+\t\t\t\t\t\"Product not found for purchase\",\r\n+\t\t\t\t\tpurchaseDto[i].productId\r\n+\t\t\t\t);\r\n \t\t\t\treturn new NotFoundResponse(\r\n-\t\t\t\t\t\"Product not found with ID: \" + purchase.productId,\r\n+\t\t\t\t\t\"Product not found with ID: \" + purchaseDto[i].productId,\r\n \t\t\t\t\t\"Please provide a valid product ID\"\r\n \t\t\t\t);\r\n \t\t\t}\r\n \t\t\t//Check if Product Category Exists\r\n@@ -130,9 +135,9 @@\n \t\t\t\tfoundProductCategory instanceof NotFoundResponse\r\n \t\t\t) {\r\n \t\t\t\tthis.logger.error(\r\n \t\t\t\t\t\"Product category not found for purchase\",\r\n-\t\t\t\t\tpurchase.productId\r\n+\t\t\t\t\tpurchaseDto[i].productId\r\n \t\t\t\t);\r\n \t\t\t\treturn new NotFoundResponse(\r\n \t\t\t\t\t\"Product category not found\",\r\n \t\t\t\t\t\"Please provide a valid product ID\"\r\n@@ -183,9 +188,9 @@\n \t\t\t\t`Processing purchase for user ${userResponse.username} of product ${productResponse.name} from business`\r\n \t\t\t);\r\n \t\t\t// Calculate total price (assuming productResponse has a price property)\r\n \t\t\tconst productPrice = productResponse.price || 0; // Assuming price is a property of Product\r\n-\t\t\ttotalPrice = productPrice * purchase.quantity;\r\n+\t\t\ttotalPrice = productPrice * purchaseDto[i].quantity;\r\n \r\n \t\t\tthis.logger.log(\r\n \t\t\t\t`Total price for product ${productResponse.name} is ${totalPrice}`\r\n \t\t\t);\r\n"
                },
                {
                    "date": 1750237072400,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,9 +110,12 @@\n \t\t\tconst productResponse = await this.productRepo.findOne({\r\n \t\t\t\twhere: { id: purchaseDto[i].productId },\r\n \t\t\t});\r\n \r\n-\t\t\tthis.logger.log(\"Product response\", productResponse);\r\n+\t\t\tthis.logger.log(\r\n+\t\t\t\t\"Product response\",\r\n+\t\t\t\tJSON.stringify(productResponse, null, 2)\r\n+\t\t\t);\r\n \t\t\tif (!productResponse || productResponse instanceof NotFoundResponse) {\r\n \t\t\t\tthis.logger.error(\r\n \t\t\t\t\t\"Product not found for purchase\",\r\n \t\t\t\t\tpurchaseDto[i].productId\r\n"
                },
                {
                    "date": 1750237136741,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -100,29 +100,23 @@\n \t\tlet totalPrice = 0;\r\n \t\tthis.logger.log(\"Total price initialized\", totalPrice);\r\n \t\tthis.logger.log(\"Purchase DTO\", JSON.stringify(purchaseDto, null, 2));\r\n \r\n-\t\tfor (let i = 0; i < purchaseDto.length; i++) {\r\n+\t\tfor (const purchase of purchaseDto) {\r\n \t\t\t//Check if Product Exist\r\n-\t\t\tthis.logger.log(\r\n-\t\t\t\t\"Checking product for purchase\",\r\n-\t\t\t\tpurchaseDto[i].productId\r\n-\t\t\t);\r\n+\t\t\tthis.logger.log(\"Checking product for purchase\", purchase.productId);\r\n \t\t\tconst productResponse = await this.productRepo.findOne({\r\n-\t\t\t\twhere: { id: purchaseDto[i].productId },\r\n+\t\t\t\twhere: { id: purchase.productId },\r\n \t\t\t});\r\n \r\n \t\t\tthis.logger.log(\r\n \t\t\t\t\"Product response\",\r\n \t\t\t\tJSON.stringify(productResponse, null, 2)\r\n \t\t\t);\r\n \t\t\tif (!productResponse || productResponse instanceof NotFoundResponse) {\r\n-\t\t\t\tthis.logger.error(\r\n-\t\t\t\t\t\"Product not found for purchase\",\r\n-\t\t\t\t\tpurchaseDto[i].productId\r\n-\t\t\t\t);\r\n+\t\t\t\tthis.logger.error(\"Product not found for purchase\", purchase.productId);\r\n \t\t\t\treturn new NotFoundResponse(\r\n-\t\t\t\t\t\"Product not found with ID: \" + purchaseDto[i].productId,\r\n+\t\t\t\t\t\"Product not found with ID: \" + purchase.productId,\r\n \t\t\t\t\t\"Please provide a valid product ID\"\r\n \t\t\t\t);\r\n \t\t\t}\r\n \t\t\t//Check if Product Category Exists\r\n@@ -138,9 +132,9 @@\n \t\t\t\tfoundProductCategory instanceof NotFoundResponse\r\n \t\t\t) {\r\n \t\t\t\tthis.logger.error(\r\n \t\t\t\t\t\"Product category not found for purchase\",\r\n-\t\t\t\t\tpurchaseDto[i].productId\r\n+\t\t\t\t\tpurchase.productId\r\n \t\t\t\t);\r\n \t\t\t\treturn new NotFoundResponse(\r\n \t\t\t\t\t\"Product category not found\",\r\n \t\t\t\t\t\"Please provide a valid product ID\"\r\n@@ -191,9 +185,9 @@\n \t\t\t\t`Processing purchase for user ${userResponse.username} of product ${productResponse.name} from business`\r\n \t\t\t);\r\n \t\t\t// Calculate total price (assuming productResponse has a price property)\r\n \t\t\tconst productPrice = productResponse.price || 0; // Assuming price is a property of Product\r\n-\t\t\ttotalPrice = productPrice * purchaseDto[i].quantity;\r\n+\t\t\ttotalPrice = productPrice * purchase.quantity;\r\n \r\n \t\t\tthis.logger.log(\r\n \t\t\t\t`Total price for product ${productResponse.name} is ${totalPrice}`\r\n \t\t\t);\r\n"
                },
                {
                    "date": 1750237247116,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,8 +66,12 @@\n \r\n \tasync findProductCategoryById(\r\n \t\tid: string\r\n \t): Promise<DataResponse<ProductCategory> | NotFoundResponse> {\r\n+\t\tif (!id) {\r\n+\t\t\tthis.logger.error(\"Product Category ID is empty or undefined\");\r\n+\t\t\treturn new NotFoundResponse(\"Product Category not found\");\r\n+\t\t}\r\n \t\tconst productCategory = await this.productCategoryRepo.findOneBy({ id });\r\n \r\n \t\tif (!productCategory) {\r\n \t\t\treturn new NotFoundResponse(\"Product Category not found\");\r\n"
                },
                {
                    "date": 1750239691413,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -124,9 +124,9 @@\n \t\t\t\t);\r\n \t\t\t}\r\n \t\t\t//Check if Product Category Exists\r\n \t\t\tconst productCategory = await this.findProductCategoryById(\r\n-\t\t\t\tproductResponse.category.id\r\n+\t\t\t\tproductResponse.categoryId\r\n \t\t\t);\r\n \t\t\tthis.logger.log(\"Purchase response\", productCategory);\r\n \r\n \t\t\tconst foundProductCategory =\r\n"
                },
                {
                    "date": 1750239915794,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -122,57 +122,9 @@\n \t\t\t\t\t\"Product not found with ID: \" + purchase.productId,\r\n \t\t\t\t\t\"Please provide a valid product ID\"\r\n \t\t\t\t);\r\n \t\t\t}\r\n-\t\t\t//Check if Product Category Exists\r\n-\t\t\tconst productCategory = await this.findProductCategoryById(\r\n-\t\t\t\tproductResponse.categoryId\r\n-\t\t\t);\r\n-\t\t\tthis.logger.log(\"Purchase response\", productCategory);\r\n-\r\n-\t\t\tconst foundProductCategory =\r\n-\t\t\t\tproductCategory instanceof DataResponse ? productCategory.data : null;\r\n-\t\t\tif (\r\n-\t\t\t\t!foundProductCategory ||\r\n-\t\t\t\tfoundProductCategory instanceof NotFoundResponse\r\n-\t\t\t) {\r\n-\t\t\t\tthis.logger.error(\r\n-\t\t\t\t\t\"Product category not found for purchase\",\r\n-\t\t\t\t\tpurchase.productId\r\n-\t\t\t\t);\r\n-\t\t\t\treturn new NotFoundResponse(\r\n-\t\t\t\t\t\"Product category not found\",\r\n-\t\t\t\t\t\"Please provide a valid product ID\"\r\n-\t\t\t\t);\r\n-\t\t\t}\r\n-\r\n-\t\t\tthis.logger.log(\r\n-\t\t\t\t\"Product category found for purchase\",\r\n-\t\t\t\tfoundProductCategory.name\r\n-\t\t\t);\r\n-\r\n-\t\t\t//Check if Business Exists\r\n-\t\t\t// const businessResponse = await this.findBusinessById(purchase.businessId);\r\n-\t\t\t// this.logger.log(\"Business response\", businessResponse);\r\n-\t\t\t// const foundBusiness =\r\n-\t\t\t// \tbusinessResponse instanceof DataResponse ? businessResponse.data : null;\r\n-\r\n-\t\t\t// if (!foundBusiness || foundBusiness instanceof NotFoundResponse) {\r\n-\t\t\t// \tthis.logger.error(\r\n-\t\t\t// \t\t\"Business not found for purchase\",\r\n-\t\t\t// \t\tpurchase.businessId\r\n-\t\t\t// \t);\r\n-\t\t\t// \treturn new InvalidCredentialsResponse(\r\n-\t\t\t// \t\t\"Business not found\",\r\n-\t\t\t// \t\t\"Please provide a valid business ID\",\r\n-\t\t\t// \t\t404\r\n-\t\t\t// \t);\r\n-\t\t\t// }\r\n-\t\t\t// this.logger.log(\r\n-\t\t\t// \t\"Business found for purchase\",\r\n-\t\t\t// \tfoundBusiness.businessName\r\n-\t\t\t// );\r\n-\r\n+\t\t\tthis.logger.log(\"Product found for purchase\", productResponse.name);\r\n \t\t\t//Check if User Exists\r\n \t\t\tconst userResponse = await this.userRepo.findOneBy({ id: userId });\r\n \t\t\tthis.logger.log(\"User response\", userResponse);\r\n \r\n@@ -189,9 +141,9 @@\n \t\t\t\t`Processing purchase for user ${userResponse.username} of product ${productResponse.name} from business`\r\n \t\t\t);\r\n \t\t\t// Calculate total price (assuming productResponse has a price property)\r\n \t\t\tconst productPrice = productResponse.price || 0; // Assuming price is a property of Product\r\n-\t\t\ttotalPrice = productPrice * purchase.quantity;\r\n+\t\t\ttotalPrice += productPrice * purchase.quantity;\r\n \r\n \t\t\tthis.logger.log(\r\n \t\t\t\t`Total price for product ${productResponse.name} is ${totalPrice}`\r\n \t\t\t);\r\n"
                },
                {
                    "date": 1750240280405,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,8 +105,10 @@\n \t\tthis.logger.log(\"Total price initialized\", totalPrice);\r\n \t\tthis.logger.log(\"Purchase DTO\", JSON.stringify(purchaseDto, null, 2));\r\n \r\n \t\tfor (const purchase of purchaseDto) {\r\n+\t\t\tthis.logger.log(\"Processing purchase for product ID\", purchase.productId);\r\n+\t\t\tthis.logger.log(\"Current Total Price\", totalPrice);\r\n \t\t\t//Check if Product Exist\r\n \t\t\tthis.logger.log(\"Checking product for purchase\", purchase.productId);\r\n \t\t\tconst productResponse = await this.productRepo.findOne({\r\n \t\t\t\twhere: { id: purchase.productId },\r\n"
                },
                {
                    "date": 1750244588463,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -142,14 +142,62 @@\n \t\t\tthis.logger.log(\r\n \t\t\t\t`Processing purchase for user ${userResponse.username} of product ${productResponse.name} from business`\r\n \t\t\t);\r\n \t\t\t// Calculate total price (assuming productResponse has a price property)\r\n-\t\t\tconst productPrice = productResponse.price || 0; // Assuming price is a property of Product\r\n+\t\t\tconst productPrice = productResponse.price || 0;\r\n \t\t\ttotalPrice += productPrice * purchase.quantity;\r\n \r\n \t\t\tthis.logger.log(\r\n+\t\t\t\t`Product price for ${productResponse.name} is ${productPrice}, quantity: ${purchase.quantity}`\r\n+\t\t\t);\r\n+\r\n+\t\t\tthis.logger.log(\r\n \t\t\t\t`Total price for product ${productResponse.name} is ${totalPrice}`\r\n \t\t\t);\r\n+\r\n+\t\t\t//Update Stock in Product Table\r\n+\t\t\tconst updateStock = await this.updateStock(\r\n+\t\t\t\tproductResponse.id,\r\n+\t\t\t\tpurchase.quantity\r\n+\t\t\t);\r\n+\t\t\tif (updateStock instanceof NotFoundResponse) {\r\n+\t\t\t\tthis.logger.error(\r\n+\t\t\t\t\t\"Failed to update stock for product\",\r\n+\t\t\t\t\tproductResponse.name\r\n+\t\t\t\t);\r\n+\t\t\t\treturn updateStock;\r\n+\t\t\t}\r\n+\r\n+\t\t\tthis.logger.log(\r\n+\t\t\t\t`Stock updated successfully for product ${productResponse.name}`\r\n+\t\t\t);\r\n+\r\n+\t\t\t// Make Transfer to Business and Save Purchase and transaction history\r\n \t\t}\r\n \t\tthis.logger.log(\"Total price calculated for all purchases\", totalPrice);\r\n \t}\r\n+\r\n+\tasync updateStock(\r\n+\t\tid: string,\r\n+\t\tquantity: number\r\n+\t): Promise<SuccessResponse | NotFoundResponse> {\r\n+\t\tthis.logger.log(`Updating stock for id: ${id} with quantity: ${quantity}`);\r\n+\r\n+\t\tconst product = await this.productRepo.findOneBy({ id });\r\n+\t\tif (!product) {\r\n+\t\t\tthis.logger.error(`Product with id ${id} not found`);\r\n+\t\t\treturn new NotFoundResponse(\r\n+\t\t\t\t\"Product not found\",\r\n+\t\t\t\t\"Please provide a valid product ID\"\r\n+\t\t\t);\r\n+\t\t}\r\n+\r\n+\t\tthis.logger.log(\r\n+\t\t\t`Product found: ${product.name}, current stock: ${product.stock}`\r\n+\t\t);\r\n+\t\tproduct.stock -= quantity;\r\n+\t\tthis.logger.log(`Updated stock: ${product.stock}`);\r\n+\t\tawait this.productRepo.update(id, { stock: product.stock });\r\n+\t\tthis.logger.log(`Stock updated successfully for product: ${product.name}`);\r\n+\t\treturn new SuccessResponse(\"Stock updated successfully\", 200);\r\n+\t}\r\n }\r\n"
                },
                {
                    "date": 1750254332871,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,8 +103,12 @@\n \r\n \t\tlet totalPrice = 0;\r\n \t\tthis.logger.log(\"Total price initialized\", totalPrice);\r\n \t\tthis.logger.log(\"Purchase DTO\", JSON.stringify(purchaseDto, null, 2));\r\n+\t\tconst paymentReference = `PAY-${Date.now()}-${Math.floor(\r\n+\t\t\tMath.random() * 1000000\r\n+\t\t)}`;\r\n+\t\tthis.logger.log(\"Generated payment reference\", paymentReference);\r\n \r\n \t\tfor (const purchase of purchaseDto) {\r\n \t\t\tthis.logger.log(\"Processing purchase for product ID\", purchase.productId);\r\n \t\t\tthis.logger.log(\"Current Total Price\", totalPrice);\r\n"
                },
                {
                    "date": 1750256039089,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n-import { Injectable, Logger } from \"@nestjs/common\";\r\n+import { Inject, Injectable, Logger } from \"@nestjs/common\";\r\n import { InjectRepository } from \"@nestjs/typeorm\";\r\n+import { randomBytes } from \"crypto\";\r\n import { Business } from \"src/entities/business.entity/business.entity\";\r\n import { User } from \"src/entities/user.entity/user.entity\";\r\n import {\r\n \tDataResponse,\r\n@@ -11,8 +12,10 @@\n import { UserResponse } from \"src/models/userResponse.dto\";\r\n import { ProductCategory } from \"src/product-categories/entities/product-category.entity\";\r\n import { Product } from \"src/products/entities/product.entity\";\r\n import { PurchaseDto } from \"src/purchase/dto/purchase.dto\";\r\n+import { Purchase } from \"src/purchase/entities/purchase.entity\";\r\n+import { TransactionDetail } from \"src/transaction-details/entities/transaction-detail.entity\";\r\n import { Repository } from \"typeorm\";\r\n \r\n @Injectable()\r\n export class SharedService {\r\n@@ -25,9 +28,13 @@\n \t\tprivate businessRepo: Repository<Business>,\r\n \t\t@InjectRepository(ProductCategory)\r\n \t\tprivate productCategoryRepo: Repository<ProductCategory>,\r\n \t\t@InjectRepository(Product)\r\n-\t\tprivate productRepo: Repository<Product>\r\n+\t\tprivate productRepo: Repository<Product>,\r\n+\t\t@InjectRepository(Purchase)\r\n+\t\tprivate readonly purchaseRepo: Repository<Purchase>,\r\n+\t\t@InjectRepository(TransactionDetail)\r\n+\t\tprivate readonly transactionDetailRepo: Repository<TransactionDetail>\r\n \t) {}\r\n \r\n \tasync findOneByEmail(\r\n \t\temail: string\r\n@@ -103,11 +110,9 @@\n \r\n \t\tlet totalPrice = 0;\r\n \t\tthis.logger.log(\"Total price initialized\", totalPrice);\r\n \t\tthis.logger.log(\"Purchase DTO\", JSON.stringify(purchaseDto, null, 2));\r\n-\t\tconst paymentReference = `PAY-${Date.now()}-${Math.floor(\r\n-\t\t\tMath.random() * 1000000\r\n-\t\t)}`;\r\n+\t\tconst paymentReference = this.generatePaymentReference();\r\n \t\tthis.logger.log(\"Generated payment reference\", paymentReference);\r\n \r\n \t\tfor (const purchase of purchaseDto) {\r\n \t\t\tthis.logger.log(\"Processing purchase for product ID\", purchase.productId);\r\n@@ -174,11 +179,61 @@\n \t\t\tthis.logger.log(\r\n \t\t\t\t`Stock updated successfully for product ${productResponse.name}`\r\n \t\t\t);\r\n \r\n-\t\t\t// Make Transfer to Business and Save Purchase and transaction history\r\n+\t\t\t// Create Purchase Record\r\n+\r\n+\t\t\tconst purchaseRecord = this.purchaseRepo.create({\r\n+\t\t\t\tquantity: purchase.quantity,\r\n+\t\t\t\tproductId: productResponse.id,\r\n+\t\t\t\tprice: productPrice * purchase.quantity,\r\n+\t\t\t\tpaymentReference: paymentReference,\r\n+\t\t\t});\r\n+\t\t\tthis.logger.log(\r\n+\t\t\t\t\"Creating purchase record\",\r\n+\t\t\t\tJSON.stringify(purchaseRecord, null, 2)\r\n+\t\t\t);\r\n+\t\t\ttry {\r\n+\t\t\t\tawait this.purchaseRepo.save(purchaseRecord);\r\n+\t\t\t\tthis.logger.log(\r\n+\t\t\t\t\t`Purchase record created successfully for product ${productResponse.name}`\r\n+\t\t\t\t);\r\n+\t\t\t} catch (error) {\r\n+\t\t\t\tthis.logger.error(\"Failed to create purchase record\", error);\r\n+\t\t\t\treturn new InvalidCredentialsResponse(\r\n+\t\t\t\t\t\"Failed to create purchase record\",\r\n+\t\t\t\t\t\"Please try again later\",\r\n+\t\t\t\t\t500\r\n+\t\t\t\t);\r\n+\t\t\t}\r\n \t\t}\r\n+\t\t// Make Transfer to Business and Save Purchase and transaction history\r\n \t\tthis.logger.log(\"Total price calculated for all purchases\", totalPrice);\r\n+\t\tconst transactionDetail = this.transactionDetailRepo.create({\r\n+\t\t\tpaymentReference: paymentReference,\r\n+\t\t\tpaymentStatus: true,\r\n+\t\t\tpaymentMethod: \"Online\",\r\n+\t\t\ttotalPrice: totalPrice,\r\n+\t\t});\r\n+\r\n+\t\tthis.logger.log(\r\n+\t\t\t\"Creating transaction detail\",\r\n+\t\t\tJSON.stringify(transactionDetail, null, 2)\r\n+\t\t);\r\n+\r\n+\t\ttry {\r\n+\t\t\tawait this.transactionDetailRepo.save(transactionDetail);\r\n+\t\t\tthis.logger.log(\r\n+\t\t\t\t`Transaction detail created successfully with reference ${paymentReference}`\r\n+\t\t\t);\r\n+\t\t} catch (error) {\r\n+\t\t\tthis.logger.error(\"Failed to create transaction detail\", error);\r\n+\t\t\treturn new InvalidCredentialsResponse(\r\n+\t\t\t\t\"Failed to create transaction detail\",\r\n+\t\t\t\t\"Please try again later\",\r\n+\t\t\t\t500\r\n+\t\t\t);\r\n+\t\t}\r\n \t}\r\n \r\n \tasync updateStock(\r\n \t\tid: string,\r\n@@ -203,5 +258,14 @@\n \t\tawait this.productRepo.update(id, { stock: product.stock });\r\n \t\tthis.logger.log(`Stock updated successfully for product: ${product.name}`);\r\n \t\treturn new SuccessResponse(\"Stock updated successfully\", 200);\r\n \t}\r\n+\r\n+\tgeneratePaymentReference(): string {\r\n+\t\tconst randomString = randomBytes(5).toString(\"hex\").toUpperCase();\r\n+\t\tthis.logger.log(\r\n+\t\t\t\"Generated random string for payment reference\",\r\n+\t\t\trandomString\r\n+\t\t);\r\n+\t\treturn `PAY-${randomString}`;\r\n+\t}\r\n }\r\n"
                },
                {
                    "date": 1750256348883,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -187,12 +187,12 @@\n \t\t\t\tproductId: productResponse.id,\r\n \t\t\t\tprice: productPrice * purchase.quantity,\r\n \t\t\t\tpaymentReference: paymentReference,\r\n \t\t\t});\r\n-\t\t\tthis.logger.log(\r\n-\t\t\t\t\"Creating purchase record\",\r\n-\t\t\t\tJSON.stringify(purchaseRecord, null, 2)\r\n-\t\t\t);\r\n+\t\t\t// this.logger.log(\r\n+\t\t\t// \t\"Creating purchase record\",\r\n+\t\t\t// \tJSON.stringify(purchaseRecord, null, 2)\r\n+\t\t\t// );\r\n \t\t\ttry {\r\n \t\t\t\tawait this.purchaseRepo.save(purchaseRecord);\r\n \t\t\t\tthis.logger.log(\r\n \t\t\t\t\t`Purchase record created successfully for product ${productResponse.name}`\r\n"
                },
                {
                    "date": 1750256779129,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -112,8 +112,14 @@\n \t\tthis.logger.log(\"Total price initialized\", totalPrice);\r\n \t\tthis.logger.log(\"Purchase DTO\", JSON.stringify(purchaseDto, null, 2));\r\n \t\tconst paymentReference = this.generatePaymentReference();\r\n \t\tthis.logger.log(\"Generated payment reference\", paymentReference);\r\n+\t\tconst transactionDetail = this.transactionDetailRepo.create({\r\n+\t\t\tpaymentReference: paymentReference,\r\n+\t\t\tpaymentStatus: false,\r\n+\t\t\tpaymentMethod: \"Online\",\r\n+\t\t\ttotalPrice: totalPrice,\r\n+\t\t});\r\n \r\n \t\tfor (const purchase of purchaseDto) {\r\n \t\t\tthis.logger.log(\"Processing purchase for product ID\", purchase.productId);\r\n \t\t\tthis.logger.log(\"Current Total Price\", totalPrice);\r\n@@ -207,16 +213,17 @@\n \t\t\t}\r\n \t\t}\r\n \t\t// Make Transfer to Business and Save Purchase and transaction history\r\n \t\tthis.logger.log(\"Total price calculated for all purchases\", totalPrice);\r\n-\t\tconst transactionDetail = this.transactionDetailRepo.create({\r\n-\t\t\tpaymentReference: paymentReference,\r\n-\t\t\tpaymentStatus: true,\r\n-\t\t\tpaymentMethod: \"Online\",\r\n-\t\t\ttotalPrice: totalPrice,\r\n-\t\t});\r\n+\t\ttransactionDetail.totalPrice = totalPrice;\r\n+\t\ttransactionDetail.paymentStatus = true;\r\n \r\n \t\tthis.logger.log(\r\n+\t\t\t\"Total price set in transaction detail\",\r\n+\t\t\ttransactionDetail.totalPrice\r\n+\t\t);\r\n+\r\n+\t\tthis.logger.log(\r\n \t\t\t\"Creating transaction detail\",\r\n \t\t\tJSON.stringify(transactionDetail, null, 2)\r\n \t\t);\r\n \r\n"
                },
                {
                    "date": 1750258701537,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -192,8 +192,9 @@\n \t\t\t\tquantity: purchase.quantity,\r\n \t\t\t\tproductId: productResponse.id,\r\n \t\t\t\tprice: productPrice * purchase.quantity,\r\n \t\t\t\tpaymentReference: paymentReference,\r\n+\t\t\t\ttransactionDetail: transactionDetail,\r\n \t\t\t});\r\n \t\t\t// this.logger.log(\r\n \t\t\t// \t\"Creating purchase record\",\r\n \t\t\t// \tJSON.stringify(purchaseRecord, null, 2)\r\n"
                },
                {
                    "date": 1750258841026,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -192,9 +192,8 @@\n \t\t\t\tquantity: purchase.quantity,\r\n \t\t\t\tproductId: productResponse.id,\r\n \t\t\t\tprice: productPrice * purchase.quantity,\r\n \t\t\t\tpaymentReference: paymentReference,\r\n-\t\t\t\ttransactionDetail: transactionDetail,\r\n \t\t\t});\r\n \t\t\t// this.logger.log(\r\n \t\t\t// \t\"Creating purchase record\",\r\n \t\t\t// \tJSON.stringify(purchaseRecord, null, 2)\r\n"
                },
                {
                    "date": 1750258908982,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -119,8 +119,13 @@\n \t\t\tpaymentMethod: \"Online\",\r\n \t\t\ttotalPrice: totalPrice,\r\n \t\t});\r\n \r\n+\t\tthis.logger.log(\r\n+\t\t\t\"Transaction detail created\",\r\n+\t\t\tJSON.stringify(transactionDetail, null, 2)\r\n+\t\t);\r\n+\r\n \t\tfor (const purchase of purchaseDto) {\r\n \t\t\tthis.logger.log(\"Processing purchase for product ID\", purchase.productId);\r\n \t\t\tthis.logger.log(\"Current Total Price\", totalPrice);\r\n \t\t\t//Check if Product Exist\r\n@@ -187,13 +192,15 @@\n \t\t\t);\r\n \r\n \t\t\t// Create Purchase Record\r\n \r\n+\t\t\t\r\n \t\t\tconst purchaseRecord = this.purchaseRepo.create({\r\n \t\t\t\tquantity: purchase.quantity,\r\n \t\t\t\tproductId: productResponse.id,\r\n \t\t\t\tprice: productPrice * purchase.quantity,\r\n \t\t\t\tpaymentReference: paymentReference,\r\n+\t\t\t\ttransactionDetail: transactionDetail\r\n \t\t\t});\r\n \t\t\t// this.logger.log(\r\n \t\t\t// \t\"Creating purchase record\",\r\n \t\t\t// \tJSON.stringify(purchaseRecord, null, 2)\r\n"
                },
                {
                    "date": 1750259025192,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -119,8 +119,9 @@\n \t\t\tpaymentMethod: \"Online\",\r\n \t\t\ttotalPrice: totalPrice,\r\n \t\t});\r\n \r\n+\t\tawait this.transactionDetailRepo.save(transactionDetail);\r\n \t\tthis.logger.log(\r\n \t\t\t\"Transaction detail created\",\r\n \t\t\tJSON.stringify(transactionDetail, null, 2)\r\n \t\t);\r\n@@ -192,15 +193,14 @@\n \t\t\t);\r\n \r\n \t\t\t// Create Purchase Record\r\n \r\n-\t\t\t\r\n \t\t\tconst purchaseRecord = this.purchaseRepo.create({\r\n \t\t\t\tquantity: purchase.quantity,\r\n \t\t\t\tproductId: productResponse.id,\r\n \t\t\t\tprice: productPrice * purchase.quantity,\r\n \t\t\t\tpaymentReference: paymentReference,\r\n-\t\t\t\ttransactionDetail: transactionDetail\r\n+\t\t\t\ttransactionDetail: transactionDetail,\r\n \t\t\t});\r\n \t\t\t// this.logger.log(\r\n \t\t\t// \t\"Creating purchase record\",\r\n \t\t\t// \tJSON.stringify(purchaseRecord, null, 2)\r\n@@ -220,10 +220,10 @@\n \t\t\t}\r\n \t\t}\r\n \t\t// Make Transfer to Business and Save Purchase and transaction history\r\n \t\tthis.logger.log(\"Total price calculated for all purchases\", totalPrice);\r\n-\t\ttransactionDetail.totalPrice = totalPrice;\r\n-\t\ttransactionDetail.paymentStatus = true;\r\n+\t\t// transactionDetail.totalPrice = totalPrice;\r\n+\t\t// transactionDetail.paymentStatus = true;\r\n \r\n \t\tthis.logger.log(\r\n \t\t\t\"Total price set in transaction detail\",\r\n \t\t\ttransactionDetail.totalPrice\r\n@@ -234,9 +234,14 @@\n \t\t\tJSON.stringify(transactionDetail, null, 2)\r\n \t\t);\r\n \r\n \t\ttry {\r\n-\t\t\tawait this.transactionDetailRepo.save(transactionDetail);\r\n+\t\t\tawait this.transactionDetailRepo.update(transactionDetail.id, {\r\n+\t\t\t\t...transactionDetail,\r\n+\t\t\t\ttotalPrice: totalPrice,\r\n+\t\t\t\tpaymentStatus: true,\r\n+\t\t\t\tupdatedAt: new Date(),\r\n+\t\t\t});\r\n \t\t\tthis.logger.log(\r\n \t\t\t\t`Transaction detail created successfully with reference ${paymentReference}`\r\n \t\t\t);\r\n \t\t} catch (error) {\r\n"
                },
                {
                    "date": 1750259242233,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -251,8 +251,14 @@\n \t\t\t\t\"Please try again later\",\r\n \t\t\t\t500\r\n \t\t\t);\r\n \t\t}\r\n+\r\n+\t\tthis.logger.log(\r\n+\t\t\t`Transaction detail updated successfully with reference ${paymentReference}`\r\n+\t\t);\r\n+\r\n+\t\treturn new SuccessResponse(\"Purchase completed successfully\", 200);\r\n \t}\r\n \r\n \tasync updateStock(\r\n \t\tid: string,\r\n"
                },
                {
                    "date": 1750260723553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -125,8 +125,21 @@\n \t\t\t\"Transaction detail created\",\r\n \t\t\tJSON.stringify(transactionDetail, null, 2)\r\n \t\t);\r\n \r\n+\t\t//Check if User Exists\r\n+\t\tconst userResponse = await this.userRepo.findOneBy({ id: userId });\r\n+\t\tthis.logger.log(\"User response\", userResponse);\r\n+\r\n+\t\tif (!userResponse) {\r\n+\t\t\tthis.logger.error(\"User not found for purchase\", userId);\r\n+\t\t\treturn new NotFoundResponse(\r\n+\t\t\t\t\"User not found\",\r\n+\t\t\t\t\"Please provide a valid user ID\"\r\n+\t\t\t);\r\n+\t\t}\r\n+\t\tthis.logger.log(\"User found for purchase\", userResponse.username);\r\n+\r\n \t\tfor (const purchase of purchaseDto) {\r\n \t\t\tthis.logger.log(\"Processing purchase for product ID\", purchase.productId);\r\n \t\t\tthis.logger.log(\"Current Total Price\", totalPrice);\r\n \t\t\t//Check if Product Exist\r\n@@ -146,21 +159,9 @@\n \t\t\t\t\t\"Please provide a valid product ID\"\r\n \t\t\t\t);\r\n \t\t\t}\r\n \t\t\tthis.logger.log(\"Product found for purchase\", productResponse.name);\r\n-\t\t\t//Check if User Exists\r\n-\t\t\tconst userResponse = await this.userRepo.findOneBy({ id: userId });\r\n-\t\t\tthis.logger.log(\"User response\", userResponse);\r\n \r\n-\t\t\tif (!userResponse) {\r\n-\t\t\t\tthis.logger.error(\"User not found for purchase\", userId);\r\n-\t\t\t\treturn new NotFoundResponse(\r\n-\t\t\t\t\t\"User not found\",\r\n-\t\t\t\t\t\"Please provide a valid user ID\"\r\n-\t\t\t\t);\r\n-\t\t\t}\r\n-\t\t\tthis.logger.log(\"User found for purchase\", userResponse.username);\r\n-\r\n \t\t\tthis.logger.log(\r\n \t\t\t\t`Processing purchase for user ${userResponse.username} of product ${productResponse.name} from business`\r\n \t\t\t);\r\n \t\t\t// Calculate total price (assuming productResponse has a price property)\r\n@@ -195,17 +196,13 @@\n \t\t\t// Create Purchase Record\r\n \r\n \t\t\tconst purchaseRecord = this.purchaseRepo.create({\r\n \t\t\t\tquantity: purchase.quantity,\r\n-\t\t\t\tproductId: productResponse.id,\r\n+\t\t\t\tproductId: purchase.productId,\r\n \t\t\t\tprice: productPrice * purchase.quantity,\r\n \t\t\t\tpaymentReference: paymentReference,\r\n \t\t\t\ttransactionDetail: transactionDetail,\r\n \t\t\t});\r\n-\t\t\t// this.logger.log(\r\n-\t\t\t// \t\"Creating purchase record\",\r\n-\t\t\t// \tJSON.stringify(purchaseRecord, null, 2)\r\n-\t\t\t// );\r\n \t\t\ttry {\r\n \t\t\t\tawait this.purchaseRepo.save(purchaseRecord);\r\n \t\t\t\tthis.logger.log(\r\n \t\t\t\t\t`Purchase record created successfully for product ${productResponse.name}`\r\n"
                },
                {
                    "date": 1750262329461,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -200,8 +200,9 @@\n \t\t\t\tproductId: purchase.productId,\r\n \t\t\t\tprice: productPrice * purchase.quantity,\r\n \t\t\t\tpaymentReference: paymentReference,\r\n \t\t\t\ttransactionDetail: transactionDetail,\r\n+\t\t\t\tuser: userResponse,\r\n \t\t\t});\r\n \t\t\ttry {\r\n \t\t\t\tawait this.purchaseRepo.save(purchaseRecord);\r\n \t\t\t\tthis.logger.log(\r\n"
                },
                {
                    "date": 1750262573606,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -196,9 +196,9 @@\n \t\t\t// Create Purchase Record\r\n \r\n \t\t\tconst purchaseRecord = this.purchaseRepo.create({\r\n \t\t\t\tquantity: purchase.quantity,\r\n-\t\t\t\tproductId: purchase.productId,\r\n+\t\t\t\tproduct: productResponse,\r\n \t\t\t\tprice: productPrice * purchase.quantity,\r\n \t\t\t\tpaymentReference: paymentReference,\r\n \t\t\t\ttransactionDetail: transactionDetail,\r\n \t\t\t\tuser: userResponse,\r\n"
                },
                {
                    "date": 1750265522149,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n import { Inject, Injectable, Logger } from \"@nestjs/common\";\r\n import { InjectRepository } from \"@nestjs/typeorm\";\r\n+import axios from \"axios\";\r\n import { randomBytes } from \"crypto\";\r\n import { Business } from \"src/entities/business.entity/business.entity\";\r\n import { User } from \"src/entities/user.entity/user.entity\";\r\n import {\r\n@@ -11,16 +12,19 @@\n } from \"src/models/response.dto\";\r\n import { UserResponse } from \"src/models/userResponse.dto\";\r\n import { ProductCategory } from \"src/product-categories/entities/product-category.entity\";\r\n import { Product } from \"src/products/entities/product.entity\";\r\n+import { PaymentDto } from \"src/purchase/dto/payment.dto\";\r\n import { PurchaseDto } from \"src/purchase/dto/purchase.dto\";\r\n import { Purchase } from \"src/purchase/entities/purchase.entity\";\r\n import { TransactionDetail } from \"src/transaction-details/entities/transaction-detail.entity\";\r\n import { Repository } from \"typeorm\";\r\n \r\n @Injectable()\r\n export class SharedService {\r\n \tprivate readonly logger = new Logger(SharedService.name);\r\n+\tprivate readonly paystackUrl = process.env.PAYSTACK_URL;\r\n+\tprivate readonly paystackSecretKey = process.env.PAYSTACK_SECRET_KEY;\r\n \r\n \tconstructor(\r\n \t\t@InjectRepository(User)\r\n \t\tprivate userRepo: Repository<User>,\r\n@@ -231,9 +235,28 @@\n \t\t\t\"Creating transaction detail\",\r\n \t\t\tJSON.stringify(transactionDetail, null, 2)\r\n \t\t);\r\n \r\n+\t\tconst paymentDetail = new PaymentDto();\r\n+\t\tpaymentDetail.amount = totalPrice * 100; // Paystack expects amount in kobo\r\n+\t\tpaymentDetail.email = userResponse.email;\r\n+\t\tpaymentDetail.reference = paymentReference;\r\n+\t\tthis.logger.log(`Payment detail created`, paymentDetail);\r\n+\r\n \t\ttry {\r\n+\t\t\tconst paymentResponse = await this.initiatePayment(paymentDetail);\r\n+\t\t\tthis.logger.log(\"Payment response received\", paymentResponse);\r\n+\r\n+\t\t\tif (paymentResponse instanceof InvalidCredentialsResponse) {\r\n+\t\t\t\tthis.logger.error(\"Payment initiation failed\", paymentResponse.message);\r\n+\t\t\t\tawait this.transactionDetailRepo.update(transactionDetail.id, {\r\n+\t\t\t\t\t...transactionDetail,\r\n+\t\t\t\t\ttotalPrice: totalPrice,\r\n+\t\t\t\t\tpaymentStatus: false,\r\n+\t\t\t\t\tupdatedAt: new Date(),\r\n+\t\t\t\t});\r\n+\t\t\t\treturn paymentResponse;\r\n+\t\t\t}\r\n \t\t\tawait this.transactionDetailRepo.update(transactionDetail.id, {\r\n \t\t\t\t...transactionDetail,\r\n \t\t\t\ttotalPrice: totalPrice,\r\n \t\t\t\tpaymentStatus: true,\r\n@@ -290,5 +313,59 @@\n \t\t\trandomString\r\n \t\t);\r\n \t\treturn `PAY-${randomString}`;\r\n \t}\r\n+\r\n+\tasync initiatePayment(\r\n+\t\tpaymentDto: PaymentDto\r\n+\t): Promise<\r\n+\t\tDataResponse<any> | InvalidCredentialsResponse | NotFoundResponse\r\n+\t> {\r\n+\t\tthis.logger.log(\"Initiating payment\");\r\n+\t\tconst headers = {\r\n+\t\t\t\"Content-Type\": \"application/json\",\r\n+\t\t\tAuthorization: `Bearer ${this.paystackSecretKey}`,\r\n+\t\t};\r\n+\t\ttry {\r\n+\t\t\tconst response = await axios.post(\r\n+\t\t\t\t`${this.paystackUrl}/transaction/initialize`,\r\n+\t\t\t\t{\r\n+\t\t\t\t\tpaymentDto,\r\n+\t\t\t\t},\r\n+\t\t\t\t{ headers: headers }\r\n+\t\t\t);\r\n+\t\t\tthis.logger.log(\"Payment response received\", response?.data);\r\n+\t\t\tthis.logger.log(\"Payment response\", response?.data);\r\n+\t\t\tif (response.data.status) {\r\n+\t\t\t\tthis.logger.log(\"Payment initiated successfully\", response.data);\r\n+\t\t\t\treturn new DataResponse(\r\n+\t\t\t\t\tresponse.data,\r\n+\t\t\t\t\t\"Payment initiated successfully\"\r\n+\t\t\t\t);\r\n+\t\t\t} else {\r\n+\t\t\t\tthis.logger.error(\"Payment initiation failed\", response.data.message);\r\n+\t\t\t\treturn new InvalidCredentialsResponse(\r\n+\t\t\t\t\t\"Payment initiation failed\",\r\n+\t\t\t\t\tresponse.data.message,\r\n+\t\t\t\t\t400\r\n+\t\t\t\t);\r\n+\t\t\t}\r\n+\t\t} catch (error) {\r\n+\t\t\tthis.logger.error(\"Error initiating payment\", error);\r\n+\t\t\tif (axios.isAxiosError(error)) {\r\n+\t\t\t\tthis.logger.error(\"Axios error occurred\", error.message);\r\n+\t\t\t\treturn new InvalidCredentialsResponse(\r\n+\t\t\t\t\t\"Payment initiation failed\",\r\n+\t\t\t\t\terror.message,\r\n+\t\t\t\t\t500\r\n+\t\t\t\t);\r\n+\t\t\t} else {\r\n+\t\t\t\tthis.logger.error(\"Unexpected error occurred\", error);\r\n+\t\t\t\treturn new InvalidCredentialsResponse(\r\n+\t\t\t\t\t\"Payment initiation failed\",\r\n+\t\t\t\t\t\"An unexpected error occurred\",\r\n+\t\t\t\t\t500\r\n+\t\t\t\t);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n }\r\n"
                },
                {
                    "date": 1750265702868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -328,9 +328,11 @@\n \t\ttry {\r\n \t\t\tconst response = await axios.post(\r\n \t\t\t\t`${this.paystackUrl}/transaction/initialize`,\r\n \t\t\t\t{\r\n-\t\t\t\t\tpaymentDto,\r\n+\t\t\t\t\tamount: paymentDto.amount,\r\n+\t\t\t\t\temail: paymentDto.email,\r\n+\t\t\t\t\treference: paymentDto.reference,\r\n \t\t\t\t},\r\n \t\t\t\t{ headers: headers }\r\n \t\t\t);\r\n \t\t\tthis.logger.log(\"Payment response received\", response?.data);\r\n"
                },
                {
                    "date": 1750265725113,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -327,13 +327,9 @@\n \t\t};\r\n \t\ttry {\r\n \t\t\tconst response = await axios.post(\r\n \t\t\t\t`${this.paystackUrl}/transaction/initialize`,\r\n-\t\t\t\t{\r\n-\t\t\t\t\tamount: paymentDto.amount,\r\n-\t\t\t\t\temail: paymentDto.email,\r\n-\t\t\t\t\treference: paymentDto.reference,\r\n-\t\t\t\t},\r\n+\t\t\t\tpaymentDto,\r\n \t\t\t\t{ headers: headers }\r\n \t\t\t);\r\n \t\t\tthis.logger.log(\"Payment response received\", response?.data);\r\n \t\t\tthis.logger.log(\"Payment response\", response?.data);\r\n"
                },
                {
                    "date": 1750266269814,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -236,9 +236,9 @@\n \t\t\tJSON.stringify(transactionDetail, null, 2)\r\n \t\t);\r\n \r\n \t\tconst paymentDetail = new PaymentDto();\r\n-\t\tpaymentDetail.amount = totalPrice * 100; // Paystack expects amount in kobo\r\n+\t\tpaymentDetail.amount = totalPrice.toFixed(2); // Paystack expects amount in kobo\r\n \t\tpaymentDetail.email = userResponse.email;\r\n \t\tpaymentDetail.reference = paymentReference;\r\n \t\tthis.logger.log(`Payment detail created`, paymentDetail);\r\n \r\n"
                },
                {
                    "date": 1750266635571,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -321,15 +321,19 @@\n \t\tDataResponse<any> | InvalidCredentialsResponse | NotFoundResponse\r\n \t> {\r\n \t\tthis.logger.log(\"Initiating payment\");\r\n \t\tconst headers = {\r\n+\t\t\tAuthorization: `Bearer ${this.paystackSecretKey}`,\r\n \t\t\t\"Content-Type\": \"application/json\",\r\n-\t\t\tAuthorization: `Bearer ${this.paystackSecretKey}`,\r\n \t\t};\r\n \t\ttry {\r\n \t\t\tconst response = await axios.post(\r\n \t\t\t\t`${this.paystackUrl}/transaction/initialize`,\r\n-\t\t\t\tpaymentDto,\r\n+\t\t\t\t{\r\n+\t\t\t\t\temail: paymentDto.email,\r\n+\t\t\t\t\tamount: parseFloat(paymentDto.amount) * 100, // Paystack expects amount in kobo\r\n+\t\t\t\t\treference: paymentDto.reference,\r\n+\t\t\t\t},\r\n \t\t\t\t{ headers: headers }\r\n \t\t\t);\r\n \t\t\tthis.logger.log(\"Payment response received\", response?.data);\r\n \t\t\tthis.logger.log(\"Payment response\", response?.data);\r\n"
                },
                {
                    "date": 1750266904748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -236,9 +236,9 @@\n \t\t\tJSON.stringify(transactionDetail, null, 2)\r\n \t\t);\r\n \r\n \t\tconst paymentDetail = new PaymentDto();\r\n-\t\tpaymentDetail.amount = totalPrice.toFixed(2); // Paystack expects amount in kobo\r\n+\t\tpaymentDetail.amount = totalPrice.toLocaleString(); // Paystack expects amount in kobo\r\n \t\tpaymentDetail.email = userResponse.email;\r\n \t\tpaymentDetail.reference = paymentReference;\r\n \t\tthis.logger.log(`Payment detail created`, paymentDetail);\r\n \r\n"
                },
                {
                    "date": 1750266913954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -236,9 +236,9 @@\n \t\t\tJSON.stringify(transactionDetail, null, 2)\r\n \t\t);\r\n \r\n \t\tconst paymentDetail = new PaymentDto();\r\n-\t\tpaymentDetail.amount = totalPrice.toLocaleString(); // Paystack expects amount in kobo\r\n+\t\tpaymentDetail.amount = totalPrice.toLocaleString(\"NGN\"); // Paystack expects amount in kobo\r\n \t\tpaymentDetail.email = userResponse.email;\r\n \t\tpaymentDetail.reference = paymentReference;\r\n \t\tthis.logger.log(`Payment detail created`, paymentDetail);\r\n \r\n"
                },
                {
                    "date": 1750267029100,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -329,9 +329,10 @@\n \t\t\tconst response = await axios.post(\r\n \t\t\t\t`${this.paystackUrl}/transaction/initialize`,\r\n \t\t\t\t{\r\n \t\t\t\t\temail: paymentDto.email,\r\n-\t\t\t\t\tamount: parseFloat(paymentDto.amount) * 100, // Paystack expects amount in kobo\r\n+\t\t\t\t\tamount: Math.round(parseFloat(paymentDto.amount) * 100),\r\n+\t\t\t\t\t// Paystack expects amount in kobo\r\n \t\t\t\t\treference: paymentDto.reference,\r\n \t\t\t\t},\r\n \t\t\t\t{ headers: headers }\r\n \t\t\t);\r\n"
                },
                {
                    "date": 1750268151028,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -240,11 +240,11 @@\n \t\tpaymentDetail.amount = totalPrice.toLocaleString(\"NGN\"); // Paystack expects amount in kobo\r\n \t\tpaymentDetail.email = userResponse.email;\r\n \t\tpaymentDetail.reference = paymentReference;\r\n \t\tthis.logger.log(`Payment detail created`, paymentDetail);\r\n-\r\n+\t\tlet paymentResponse: DataResponse<any> | InvalidCredentialsResponse;\r\n \t\ttry {\r\n-\t\t\tconst paymentResponse = await this.initiatePayment(paymentDetail);\r\n+\t\t\tpaymentResponse = await this.initiatePayment(paymentDetail);\r\n \t\t\tthis.logger.log(\"Payment response received\", paymentResponse);\r\n \r\n \t\t\tif (paymentResponse instanceof InvalidCredentialsResponse) {\r\n \t\t\t\tthis.logger.error(\"Payment initiation failed\", paymentResponse.message);\r\n@@ -276,10 +276,12 @@\n \r\n \t\tthis.logger.log(\r\n \t\t\t`Transaction detail updated successfully with reference ${paymentReference}`\r\n \t\t);\r\n-\r\n-\t\treturn new SuccessResponse(\"Purchase completed successfully\", 200);\r\n+\t\treturn new DataResponse<PurchaseDto>(\r\n+\t\t\tpaymentResponse.data,\r\n+\t\t\t\"Purchase completed successfully\"\r\n+\t\t);\r\n \t}\r\n \r\n \tasync updateStock(\r\n \t\tid: string,\r\n"
                },
                {
                    "date": 1751980125924,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,7 @@\n import { Inject, Injectable, Logger } from \"@nestjs/common\";\r\n+import { ConfigService } from \"@nestjs/config\";\r\n+import { JwtService } from \"@nestjs/jwt\";\r\n import { InjectRepository } from \"@nestjs/typeorm\";\r\n import axios from \"axios\";\r\n import { randomBytes } from \"crypto\";\r\n import { Business } from \"src/entities/business.entity/business.entity\";\r\n@@ -8,12 +10,13 @@\n \tDataResponse,\r\n \tInvalidCredentialsResponse,\r\n \tNotFoundResponse,\r\n \tSuccessResponse,\r\n+\tUnauthorizedResponse,\r\n } from \"src/models/response.dto\";\r\n import { UserResponse } from \"src/models/userResponse.dto\";\r\n-import { ProductCategory } from \"src/product-categories/entities/product-category.entity\";\r\n-import { Product } from \"src/products/entities/product.entity\";\r\n+import { ProductCategory } from \"src/product-categories/entities/product-category\";\r\n+import { Product } from \"src/products/entities/products.entity\";\r\n import { PaymentDto } from \"src/purchase/dto/payment.dto\";\r\n import { PurchaseDto } from \"src/purchase/dto/purchase.dto\";\r\n import { Purchase } from \"src/purchase/entities/purchase.entity\";\r\n import { TransactionDetail } from \"src/transaction-details/entities/transaction-detail.entity\";\r\n@@ -36,11 +39,29 @@\n \t\tprivate productRepo: Repository<Product>,\r\n \t\t@InjectRepository(Purchase)\r\n \t\tprivate readonly purchaseRepo: Repository<Purchase>,\r\n \t\t@InjectRepository(TransactionDetail)\r\n-\t\tprivate readonly transactionDetailRepo: Repository<TransactionDetail>\r\n+\t\tprivate readonly transactionDetailRepo: Repository<TransactionDetail>,\r\n+\t\tprivate readonly jwtService: JwtService,\r\n+\t\tprivate readonly configService: ConfigService\r\n \t) {}\r\n \r\n+\tasync decodeToken(\r\n+\t\ttoken: string\r\n+\t): Promise<DataResponse<any> | UnauthorizedResponse> {\r\n+\t\ttry {\r\n+\t\t\tconst decoded = this.jwtService.verify(token, {\r\n+\t\t\t\tsecret: this.configService.get<string>(\"JWT_SECRET\"),\r\n+\t\t\t});\r\n+\t\t\treturn decoded\r\n+\t\t\t\t? new DataResponse(decoded.sub, \"Token decoded successfully\")\r\n+\t\t\t\t: new UnauthorizedResponse(\"Invalid token\");\r\n+\t\t} catch (error) {\r\n+\t\t\tconsole.error(\"Token decoding error:\", error);\r\n+\t\t\treturn new UnauthorizedResponse(\"Invalid token\");\r\n+\t\t}\r\n+\t}\r\n+\r\n \tasync findOneByEmail(\r\n \t\temail: string\r\n \t): Promise<DataResponse<User> | NotFoundResponse> {\r\n \t\tconst user = await this.userRepo.findOneBy({ email });\r\n"
                },
                {
                    "date": 1751980671350,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,8 +60,22 @@\n \t\t\treturn new UnauthorizedResponse(\"Invalid token\");\r\n \t\t}\r\n \t}\r\n \r\n+\tasync verifyUserIsAdmin(username: string): Promise<boolean> {\r\n+\t\tconst user = await this.userRepo.findOneBy({ username });\r\n+\t\tif (!user) {\r\n+\t\t\tthis.logger.error(`User with username: ${username} not found`);\r\n+\t\t\treturn false;\r\n+\t\t}\r\n+\t\tif (user.userType !== \"ADMIN\") {\r\n+\t\t\tthis.logger.warn(`User with username: ${username} is not an admin`);\r\n+\t\t\treturn false;\r\n+\t\t}\r\n+\t\tthis.logger.log(`User with username: ${username} is an admin`);\r\n+\t\treturn true;\r\n+\t}\r\n+\r\n \tasync findOneByEmail(\r\n \t\temail: string\r\n \t): Promise<DataResponse<User> | NotFoundResponse> {\r\n \t\tconst user = await this.userRepo.findOneBy({ email });\r\n"
                },
                {
                    "date": 1751982396543,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,8 +85,20 @@\n \t\t}\r\n \t\treturn new DataResponse<User>(user, \"User found\");\r\n \t}\r\n \r\n+\tasync findOneById(\r\n+\t\tid: string\r\n+\t): Promise<DataResponse<UserResponse> | NotFoundResponse> {\r\n+\t\tconst user = await this.userRepo.findOneBy({ id });\r\n+\r\n+\t\tif (!user) {\r\n+\t\t\treturn new NotFoundResponse(\"User not found\");\r\n+\t\t}\r\n+\r\n+\t\treturn new DataResponse<UserResponse>(user, \"User Found\");\r\n+\t}\r\n+\r\n \tasync findOneByUsername(\r\n \t\tusername: string\r\n \t): Promise<DataResponse<UserResponse> | NotFoundResponse> {\r\n \t\tconst user = await this.userRepo.findOneBy({ username });\r\n"
                },
                {
                    "date": 1751983448956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,9 @@\n import { InjectRepository } from \"@nestjs/typeorm\";\r\n import axios from \"axios\";\r\n import { randomBytes } from \"crypto\";\r\n import { Business } from \"src/entities/business.entity/business.entity\";\r\n+import { UserType } from \"src/entities/enum\";\r\n import { User } from \"src/entities/user.entity/user.entity\";\r\n import {\r\n \tDataResponse,\r\n \tInvalidCredentialsResponse,\r\n@@ -66,9 +67,9 @@\n \t\tif (!user) {\r\n \t\t\tthis.logger.error(`User with username: ${username} not found`);\r\n \t\t\treturn false;\r\n \t\t}\r\n-\t\tif (user.userType !== \"ADMIN\") {\r\n+\t\tif (user.userType !== UserType.ADMIN) {\r\n \t\t\tthis.logger.warn(`User with username: ${username} is not an admin`);\r\n \t\t\treturn false;\r\n \t\t}\r\n \t\tthis.logger.log(`User with username: ${username} is an admin`);\r\n"
                },
                {
                    "date": 1751983534215,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,20 @@\n \t\t\treturn new UnauthorizedResponse(\"Invalid token\");\r\n \t\t}\r\n \t}\r\n \r\n-\tasync verifyUserIsAdmin(username: string): Promise<boolean> {\r\n+\tasync verifyUserIsAdmin(\r\n+\t\tusername: string\r\n+\t): Promise<boolean | InvalidCredentialsResponse> {\r\n+\t\tconsole.log(`Verifying if user with username: ${username} is an admin`);\r\n+\t\tthis.logger.log(`Verifying if user with username: ${username} is an admin`);\r\n+\t\tif (!username) {\r\n+\t\t\treturn new InvalidCredentialsResponse(\r\n+\t\t\t\t\"Username is required\",\r\n+\t\t\t\t\"Please provide a valid username\",\r\n+\t\t\t\t400\r\n+\t\t\t);\r\n+\t\t}\r\n \t\tconst user = await this.userRepo.findOneBy({ username });\r\n \t\tif (!user) {\r\n \t\t\tthis.logger.error(`User with username: ${username} not found`);\r\n \t\t\treturn false;\r\n"
                },
                {
                    "date": 1751983665050,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,8 +52,10 @@\n \t\ttry {\r\n \t\t\tconst decoded = this.jwtService.verify(token, {\r\n \t\t\t\tsecret: this.configService.get<string>(\"JWT_SECRET\"),\r\n \t\t\t});\r\n+\t\t\tconsole.log(\"Decoded Token:\", decoded);\r\n+\t\t\tthis.logger.log(\"Token decoded successfully\", decoded);\r\n \t\t\treturn decoded\r\n \t\t\t\t? new DataResponse(decoded.sub, \"Token decoded successfully\")\r\n \t\t\t\t: new UnauthorizedResponse(\"Invalid token\");\r\n \t\t} catch (error) {\r\n"
                },
                {
                    "date": 1751983696805,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n \t\t\t});\r\n \t\t\tconsole.log(\"Decoded Token:\", decoded);\r\n \t\t\tthis.logger.log(\"Token decoded successfully\", decoded);\r\n \t\t\treturn decoded\r\n-\t\t\t\t? new DataResponse(decoded.sub, \"Token decoded successfully\")\r\n+\t\t\t\t? new DataResponse(decoded, \"Token decoded successfully\")\r\n \t\t\t\t: new UnauthorizedResponse(\"Invalid token\");\r\n \t\t} catch (error) {\r\n \t\t\tconsole.error(\"Token decoding error:\", error);\r\n \t\t\treturn new UnauthorizedResponse(\"Invalid token\");\r\n"
                },
                {
                    "date": 1752063023086,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,8 +88,33 @@\n \t\tthis.logger.log(`User with username: ${username} is an admin`);\r\n \t\treturn true;\r\n \t}\r\n \r\n+\tasync verifyUserIsVendor(\r\n+\t\tusername: string\r\n+\t): Promise<boolean | InvalidCredentialsResponse> {\r\n+\t\tconsole.log(`Verifying if user with username: ${username} is an admin`);\r\n+\t\tthis.logger.log(`Verifying if user with username: ${username} is an admin`);\r\n+\t\tif (!username) {\r\n+\t\t\treturn new InvalidCredentialsResponse(\r\n+\t\t\t\t\"Username is required\",\r\n+\t\t\t\t\"Please provide a valid username\",\r\n+\t\t\t\t400\r\n+\t\t\t);\r\n+\t\t}\r\n+\t\tconst user = await this.userRepo.findOneBy({ username });\r\n+\t\tif (!user) {\r\n+\t\t\tthis.logger.error(`User with username: ${username} not found`);\r\n+\t\t\treturn false;\r\n+\t\t}\r\n+\t\tif (user.userType !== UserType.VENDOR) {\r\n+\t\t\tthis.logger.warn(`User with username: ${username} is not an admin`);\r\n+\t\t\treturn false;\r\n+\t\t}\r\n+\t\tthis.logger.log(`User with username: ${username} is an admin`);\r\n+\t\treturn true;\r\n+\t}\r\n+\r\n \tasync findOneByEmail(\r\n \t\temail: string\r\n \t): Promise<DataResponse<User> | NotFoundResponse> {\r\n \t\tconst user = await this.userRepo.findOneBy({ email });\r\n"
                },
                {
                    "date": 1752065206312,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,10 +91,10 @@\n \r\n \tasync verifyUserIsVendor(\r\n \t\tusername: string\r\n \t): Promise<boolean | InvalidCredentialsResponse> {\r\n-\t\tconsole.log(`Verifying if user with username: ${username} is an admin`);\r\n-\t\tthis.logger.log(`Verifying if user with username: ${username} is an admin`);\r\n+\t\tconsole.log(`Verifying if user with username: ${username} is a Vendor`);\r\n+\t\tthis.logger.log(`Verifying if user with username: ${username} is a Vendor`);\r\n \t\tif (!username) {\r\n \t\t\treturn new InvalidCredentialsResponse(\r\n \t\t\t\t\"Username is required\",\r\n \t\t\t\t\"Please provide a valid username\",\r\n@@ -106,12 +106,22 @@\n \t\t\tthis.logger.error(`User with username: ${username} not found`);\r\n \t\t\treturn false;\r\n \t\t}\r\n \t\tif (user.userType !== UserType.VENDOR) {\r\n-\t\t\tthis.logger.warn(`User with username: ${username} is not an admin`);\r\n+\t\t\tthis.logger.warn(`User with username: ${username} is not a Vendor`);\r\n \t\t\treturn false;\r\n \t\t}\r\n-\t\tthis.logger.log(`User with username: ${username} is an admin`);\r\n+\r\n+\t\tif (user.isVerified === false) {\r\n+\t\t\tthis.logger.warn(`User with username: ${username} is not verified`);\r\n+\t\t\treturn new InvalidCredentialsResponse(\r\n+\t\t\t\t\"User is not verified\",\r\n+\t\t\t\t\"Please verify your account to proceed\",\r\n+\t\t\t\t403\r\n+\t\t\t)\r\n+\t\t}\r\n+\r\n+\t\tthis.logger.log(`User with username: ${username} is a Verified Vendor`);\r\n \t\treturn true;\r\n \t}\r\n \r\n \tasync findOneByEmail(\r\n"
                },
                {
                    "date": 1752070008853,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,13 +3,15 @@\n import { JwtService } from \"@nestjs/jwt\";\r\n import { InjectRepository } from \"@nestjs/typeorm\";\r\n import axios from \"axios\";\r\n import { randomBytes } from \"crypto\";\r\n+import { EmailService } from \"src/email/email.service\";\r\n import { Business } from \"src/entities/business.entity/business.entity\";\r\n import { UserType } from \"src/entities/enum\";\r\n import { User } from \"src/entities/user.entity/user.entity\";\r\n import {\r\n \tDataResponse,\r\n+\tErrorResponse,\r\n \tInvalidCredentialsResponse,\r\n \tNotFoundResponse,\r\n \tSuccessResponse,\r\n \tUnauthorizedResponse,\r\n@@ -42,9 +44,10 @@\n \t\tprivate readonly purchaseRepo: Repository<Purchase>,\r\n \t\t@InjectRepository(TransactionDetail)\r\n \t\tprivate readonly transactionDetailRepo: Repository<TransactionDetail>,\r\n \t\tprivate readonly jwtService: JwtService,\r\n-\t\tprivate readonly configService: ConfigService\r\n+\t\tprivate readonly configService: ConfigService,\r\n+\t\tprivate readonly emailService: EmailService,\r\n \t) {}\r\n \r\n \tasync decodeToken(\r\n \t\ttoken: string\r\n@@ -208,8 +211,9 @@\n \t\t\t);\r\n \t\t}\r\n \r\n \t\tlet totalPrice = 0;\r\n+\t\tlet product = [];\r\n \t\tthis.logger.log(\"Total price initialized\", totalPrice);\r\n \t\tthis.logger.log(\"Purchase DTO\", JSON.stringify(purchaseDto, null, 2));\r\n \t\tconst paymentReference = this.generatePaymentReference();\r\n \t\tthis.logger.log(\"Generated payment reference\", paymentReference);\r\n@@ -247,8 +251,10 @@\n \t\t\tconst productResponse = await this.productRepo.findOne({\r\n \t\t\t\twhere: { id: purchase.productId },\r\n \t\t\t});\r\n \r\n+\t\t\tthis.logger.log(\"Product response for purchase\", productResponse);\r\n+\r\n \t\t\tthis.logger.log(\r\n \t\t\t\t\"Product response\",\r\n \t\t\t\tJSON.stringify(productResponse, null, 2)\r\n \t\t\t);\r\n@@ -292,8 +298,21 @@\n \t\t\tthis.logger.log(\r\n \t\t\t\t`Stock updated successfully for product ${productResponse.name}`\r\n \t\t\t);\r\n \r\n+\t\t\t// Push product response to the product array\r\n+\t\t\tproduct.push(\r\n+\t\t\t\t{\r\n+\t\t\t\t\tid: productResponse.id,\r\n+\t\t\t\t\tname: productResponse.name,\r\n+\t\t\t\t\tdescription: productResponse.description || \"No description available\",\r\n+\t\t\t\t\tunitPrice: productPrice,\r\n+\t\t\t\t\tquantity: purchase.quantity,\r\n+\t\t\t\t\ttotalPrice: productPrice * purchase.quantity,\r\n+\t\t\t\t}\r\n+\t\t\t);\r\n+\r\n+\r\n \t\t\t// Create Purchase Record\r\n \r\n \t\t\tconst purchaseRecord = this.purchaseRepo.create({\r\n \t\t\t\tquantity: purchase.quantity,\r\n@@ -332,9 +351,10 @@\n \t\t\tJSON.stringify(transactionDetail, null, 2)\r\n \t\t);\r\n \r\n \t\tconst paymentDetail = new PaymentDto();\r\n-\t\tpaymentDetail.amount = totalPrice.toLocaleString(\"NGN\"); // Paystack expects amount in kobo\r\n+\t\t// paymentDetail.amount = totalPrice.toLocaleString(\"NGN\"); // Paystack expects amount in kobo\r\n+\t\tpaymentDetail.amount = Math.round(totalPrice * 100).toString();\r\n \t\tpaymentDetail.email = userResponse.email;\r\n \t\tpaymentDetail.reference = paymentReference;\r\n \t\tthis.logger.log(`Payment detail created`, paymentDetail);\r\n \t\tlet paymentResponse: DataResponse<any> | InvalidCredentialsResponse;\r\n@@ -360,8 +380,10 @@\n \t\t\t});\r\n \t\t\tthis.logger.log(\r\n \t\t\t\t`Transaction detail created successfully with reference ${paymentReference}`\r\n \t\t\t);\r\n+\r\n+\r\n \t\t} catch (error) {\r\n \t\t\tthis.logger.error(\"Failed to create transaction detail\", error);\r\n \t\t\treturn new InvalidCredentialsResponse(\r\n \t\t\t\t\"Failed to create transaction detail\",\r\n@@ -372,8 +394,61 @@\n \r\n \t\tthis.logger.log(\r\n \t\t\t`Transaction detail updated successfully with reference ${paymentReference}`\r\n \t\t);\r\n+\r\n+\t\t// Send Email to User\r\n+\t\tconst emailContext = {\r\n+\t\t\tfirstName: userResponse.firstName,\r\n+\t\t\tlastName: userResponse.lastName,\r\n+\t\t\torderNumber: paymentReference,\r\n+\t\t\torderDate: new Date().toLocaleDateString(),\r\n+\t\t\ttotalItems: purchaseDto.reduce(\r\n+\t\t\t\t(acc, item) => acc + item.quantity,\r\n+\t\t\t\t0\r\n+\t\t\t),\r\n+\t\t\tpaymentMethod: \"PAYSTACK\",\r\n+\t\t\tproducts: product.map((item) => ({\r\n+\t\t\t\tname: item.name,\r\n+\t\t\t\tdescription: item.description || \"No description available\",\r\n+\t\t\t\tquantity: item.quantity,\r\n+\t\t\t\tunitPrice: item.unitPrice.toLocaleString(\"NGN\"),\r\n+\t\t\t\ttotal: item.totalPrice.toLocaleString(\"NGN\"),\r\n+\t\t\t\tcurrency: \"NGN\",\r\n+\t\t\t})),\r\n+\t\t\tcurrency: \"NGN\",\r\n+\t\t\tgrandTotal: totalPrice.toLocaleString(\"NGN\"),\r\n+\t\t\tsupportEmail: \"iyiolakeni@gmail.com\",\r\n+\t\t\tsupportPhone: \"+234 803 123 4567\",\r\n+\t\t\tcurrentYear: new Date().getFullYear(),\r\n+\t\t\ttrackingUrl: \"https://example.com/track-order\",\r\n+\t\t\tcompanyName: \"Thrive Marketplace\",\r\n+\t\t\tlogoUrl: \"https://example.com/logo.png\",\r\n+\t\t}\r\n+\r\n+\t\tthis.logger.log(\"Preparing to send purchase notification email\");\r\n+\t\tconst emailResponse = await this.emailService.sendEmail({\r\n+\t\t\tto: userResponse.email,\r\n+\t\t\tsubject: `Purchase Confirmation - ${paymentReference}`,\r\n+\t\t\ttemplateName: \"purchase_notification\",\r\n+\t\t\tcontext: emailContext,\r\n+\t\t});\r\n+\r\n+\t\tthis.logger.log(\"Email response\", emailResponse);\r\n+\t\tif (emailResponse instanceof ErrorResponse) {\r\n+\t\t\tthis.logger.error(\"Failed to send purchase notification email\", emailResponse);\r\n+\t\t\treturn new ErrorResponse(\r\n+\t\t\t\temailResponse.message,\r\n+\t\t\t\temailResponse.error,\r\n+\t\t\t\temailResponse.statusCode\r\n+\t\t\t);\r\n+\t\t}\r\n+\t\t\r\n+\t\tthis.logger.log(\r\n+\t\t\t`Purchase notification email sent successfully to ${userResponse.email}`\r\n+\t\t);\r\n+\r\n+\r\n \t\treturn new DataResponse<PurchaseDto>(\r\n \t\t\tpaymentResponse.data,\r\n \t\t\t\"Purchase completed successfully\"\r\n \t\t);\r\n"
                },
                {
                    "date": 1752070726680,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -231,9 +231,9 @@\n \t\t);\r\n \r\n \t\t//Check if User Exists\r\n \t\tconst userResponse = await this.userRepo.findOneBy({ id: userId });\r\n-\t\tthis.logger.log(\"User response\", userResponse);\r\n+\t\tthis.logger.log(\"User response\", JSON.stringify(userResponse, null, 2));\r\n \r\n \t\tif (!userResponse) {\r\n \t\t\tthis.logger.error(\"User not found for purchase\", userId);\r\n \t\t\treturn new NotFoundResponse(\r\n"
                },
                {
                    "date": 1752071142139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -416,8 +416,10 @@\n \t\t\tcompanyName: \"Thrive Marketplace\",\r\n \t\t\tlogoUrl: \"https://example.com/logo.png\",\r\n \t\t};\r\n \r\n+\r\n+\t\tthis.logger.log('User Response: ', JSON.stringify(userResponse, null, 2));\r\n \t\tthis.logger.log(\"Preparing to send purchase notification email\");\r\n \t\tconst emailResponse = await this.emailService.sendEmail({\r\n \t\t\tto: userResponse.email,\r\n \t\t\tsubject: `Purchase Confirmation - ${paymentReference}`,\r\n"
                },
                {
                    "date": 1752071367624,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -229,8 +229,9 @@\n \t\t\t\"Transaction detail created\",\r\n \t\t\tJSON.stringify(transactionDetail, null, 2)\r\n \t\t);\r\n \r\n+\t\tconsole.log('User ID: ', userId)\r\n \t\t//Check if User Exists\r\n \t\tconst userResponse = await this.userRepo.findOneBy({ id: userId });\r\n \t\tthis.logger.log(\"User response\", JSON.stringify(userResponse, null, 2));\r\n \r\n"
                }
            ],
            "date": 1749977315499,
            "name": "Commit-0",
            "content": "import { Injectable } from \"@nestjs/common\";\r\nimport { InjectRepository } from \"@nestjs/typeorm\";\r\nimport { Business } from \"src/entities/business.entity/business.entity\";\r\nimport { User } from \"src/entities/user.entity/user.entity\";\r\nimport { DataResponse, NotFoundResponse } from \"src/models/response.dto\";\r\nimport { UserResponse } from \"src/models/userResponse.dto\";\r\nimport { Repository } from \"typeorm\";\r\n\r\n@Injectable()\r\nexport class SharedService {\r\n\tconstructor(\r\n\t\t@InjectRepository(User)\r\n\t\tprivate userRepo: Repository<User>,\r\n\t\t@InjectRepository(Business)\r\n\t\tprivate businessRepo: Repository<Business>\r\n\t) {}\r\n\r\n\tasync findOneByEmail(\r\n\t\temail: string\r\n\t): Promise<DataResponse<User> | NotFoundResponse> {\r\n\t\tconst user = await this.userRepo.findOneBy({ email });\r\n\r\n\t\tif (!user) {\r\n\t\t\treturn new NotFoundResponse(\"User not found\");\r\n\t\t}\r\n\t\treturn new DataResponse<User>(user, \"User found\");\r\n\t}\r\n\r\n\tasync findOneByUsername(\r\n\t\tusername: string\r\n\t): Promise<DataResponse<UserResponse> | NotFoundResponse> {\r\n\t\tconst user = await this.userRepo.findOneBy({ username });\r\n\r\n\t\tif (!user) {\r\n\t\t\treturn new NotFoundResponse(\"User not found\");\r\n\t\t}\r\n\r\n\t\treturn new DataResponse<UserResponse>(user, \"User Found\");\r\n\t}\r\n\r\n\tasync findBusinessById(\r\n\t\tid: string\r\n\t): Promise<DataResponse<Business> | NotFoundResponse> {\r\n\t\tconst business = await this.businessRepo.findOneBy({ id });\r\n\r\n\t\tif (!business) {\r\n\t\t\treturn new NotFoundResponse(\"Business not found\");\r\n\t\t}\r\n\r\n\t\treturn new DataResponse<Business>(business, \"Business Found\");\r\n\t}\r\n}\r\n"
        }
    ]
}